---
interface Heading {
  depth: number;
  slug: string;
  text: string;
}

interface Props {
  headings: Heading[];
  title?: string;
}

const { headings, title = 'Contents' } = Astro.props;

// Convert flat headings to nested structure
interface TreeItem {
  heading: Heading;
  children: TreeItem[];
}

function buildTree(headings: Heading[]): TreeItem[] {
  const result: TreeItem[] = [];
  const stack: { item: TreeItem; depth: number }[] = [];

  for (const heading of headings) {
    const item: TreeItem = { heading, children: [] };

    // Pop items from stack that are at same or deeper level
    while (stack.length > 0 && stack[stack.length - 1].depth >= heading.depth) {
      stack.pop();
    }

    if (stack.length === 0) {
      result.push(item);
    } else {
      stack[stack.length - 1].item.children.push(item);
    }

    stack.push({ item, depth: heading.depth });
  }

  return result;
}

const tree = buildTree(headings);
---

<div class="toc" id="toc-nav">
  <div class="toc__title">{title}</div>
  {tree.map((item) => (
    <div>
      <a
        href={`#${item.heading.slug}`}
        class="toc__link toc__link--parent hover:no-underline"
        data-toc-link={item.heading.slug}
      >
        {item.heading.text}
      </a>
      {item.children.length > 0 && (
        <div class="toc__children">
          {item.children.map((child) => (
            <a
              href={`#${child.heading.slug}`}
              class="toc__link hover:no-underline"
              data-toc-link={child.heading.slug}
            >
              {child.heading.text}
            </a>
          ))}
        </div>
      )}
    </div>
  ))}
</div>

<style>
  .toc__link--active {
    color: var(--color-accent) !important;
    border-left: 2px solid var(--color-accent);
    padding-left: 0.5rem;
    margin-left: -0.5rem;
  }
</style>

<script>
  function initActiveToc() {
    const tocLinks = document.querySelectorAll('[data-toc-link]');
    if (tocLinks.length === 0) return;

    const headingElements: { id: string; el: Element }[] = [];
    tocLinks.forEach((link) => {
      const slug = (link as HTMLElement).dataset.tocLink;
      if (slug) {
        const heading = document.getElementById(slug);
        if (heading) headingElements.push({ id: slug, el: heading });
      }
    });

    if (headingElements.length === 0) return;

    let activeSlug = '';

    const observer = new IntersectionObserver(
      (entries) => {
        // Find the topmost visible heading
        let topVisible = '';
        let topY = Infinity;

        entries.forEach((entry) => {
          if (entry.isIntersecting && entry.boundingClientRect.top < topY) {
            topY = entry.boundingClientRect.top;
            topVisible = entry.target.id;
          }
        });

        if (topVisible && topVisible !== activeSlug) {
          activeSlug = topVisible;
          tocLinks.forEach((link) => {
            const slug = (link as HTMLElement).dataset.tocLink;
            link.classList.toggle('toc__link--active', slug === activeSlug);
          });
        }
      },
      {
        rootMargin: '-80px 0px -60% 0px',
        threshold: 0,
      }
    );

    headingElements.forEach(({ el }) => observer.observe(el));
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initActiveToc);
  } else {
    initActiveToc();
  }

  document.addEventListener('astro:page-load', initActiveToc);
</script>
